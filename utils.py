import os
import math
import hashlib
#import pandas as pd
import pefile
import csv
from PIL import Image
from contextlib import redirect_stdout
import numpy as np

def get_entropy(data):
    
    """
    This function computes the entropy of input 
    
    Input: data
    
    Returns: The entropy of the input data
    """
    if not data:
        return 0
    entropy = 0
    for x in range(256):
        p_x = float(data.count(chr(x)))/len(data)
        if p_x > 0:
            entropy += - p_x*math.log(p_x, 2)
    return entropy

def EXTRACT_OPTIONAL_HEADER_INFO(file_path):
    """
    Extracts optional header information of the exe file
    
    Input: Takes input as the file path
    Ouput: Returns the header information in the form of dictionary
    """
    LResource = {}
    pefile_info = pefile.PE(file_path)
    LResource['Name'] = file_path
    LResource['MajorLinkerVersion'] = pefile_info.OPTIONAL_HEADER.MajorLinkerVersion
    LResource['MinorLinkerVersion'] = pefile_info.OPTIONAL_HEADER.MinorLinkerVersion
    LResource['SizeOfCode'] = pefile_info.OPTIONAL_HEADER.SizeOfCode
    LResource['SizeOfInitializedData'] = pefile_info.OPTIONAL_HEADER.SizeOfInitializedData
    LResource['SizeOfUninitializedData'] = pefile_info.OPTIONAL_HEADER.SizeOfUninitializedData

    try:
        LResource['AddressOfEntryPoint'] = pefile_info.OPTIONAL_HEADER.AddressOfEntryPoint
        LResource['BaseOfCode'] = pefile_info.OPTIONAL_HEADER.BaseOfCode
        LResource['ImageBase'] = pefile_info.OPTIONAL_HEADER.ImageBase
    except:
        LResource['AddressOfEntyPoint'] = 0
        LResource['BaseOfCode'] = 0
        LResource['ImageBase'] = 0
    LResource['SectionAlignment'] = pefile_info.OPTIONAL_HEADER.SectionAlignment
    LResource['FileAlignment'] = pefile_info.OPTIONAL_HEADER.FileAlignment
    LResource['MajorOperatingSystemVersion'] = pefile_info.OPTIONAL_HEADER.MajorOperatingSystemVersion
    LResource['MajorImageVersion'] = pefile_info.OPTIONAL_HEADER.MajorImageVersion
    LResource['MinorImageVersion'] = pefile_info.OPTIONAL_HEADER.MinorImageVersion
    LResource['MajorSubsystemVerison'] = pefile_info.OPTIONAL_HEADER.MajorSubsystemVersion
    LResource['MinorSubsystemVersion'] = pefile_info.OPTIONAL_HEADER.MinorSubsystemVersion
    LResource['SizeOfImage'] = pefile_info.OPTIONAL_HEADER.SizeOfImage
    LResource['SizeOfHeaders'] = pefile_info.OPTIONAL_HEADER.SizeOfHeaders
    LResource['Subsystem'] = pefile_info.OPTIONAL_HEADER.Subsystem
    LResource['DllCharacteristics'] = pefile_info.OPTIONAL_HEADER.DllCharacteristics

    try:
        LResource['SizeOfStackReserve'] = pefile_info.OPTIONAL_HEADER.SizeOfStackReserve
        LResource['SizeOfStackCommit'] = pefile_info.OPTIONAL_HEADER.SizeOfStackCommit
        LResource['SizeOfHeapReserve'] = pefile_info.OPTIONAL_HEADER.SizeOfHeapReserve
    except:
        LResource['SizeOfStackReserve'] = 0
        LResource['SizeOfStackCommit'] = 0
        LResource['SizeOfHeapReserve'] = 0

    LResource['SizeOfHeapCommit'] = pefile_info.OPTIONAL_HEADER.SizeOfHeapCommit
    LResource['LoaderFlags'] = pefile_info.OPTIONAL_HEADER.LoaderFlags
    LResource['NumberOfRvaAndSizes'] = pefile_info.OPTIONAL_HEADER.NumberOfRvaAndSizes
    entropy = []
    characteristics = []
    raw_sizes = []
    Misc_list = []

    #initialize virtual address_list and raw sizes and entropy
    #check the suspecious sections
    for m in pefile_info.sections:
        entropy.append(m.get_entropy())
        characteristics.append(m.Characteristics)
        raw_sizes.append(m.SizeOfRawData)
        Misc_list.append(m.Misc)
        
    #initialize Section
    LResource['SelectionsMeanEntropy'] = sum(entropy) / float(len(entropy))
    LResource['SectionsMinEntropy'] = min(entropy)
    LResource['SectionMaxEntropy'] = max(entropy)

    #initialize Characteristics
    LResource['CharacteristicsMean'] = sum(characteristics) / float(len(characteristics))
    LResource['CharacteristicsMin'] = min(characteristics)
    LResource['CharacteristicsMax'] = max(characteristics)

    #initialize Misc
    LResource['MiscMean'] = sum(Misc_list) / float(len(Misc_list))
    LResource['MiscMin'] = min(Misc_list)
    LResource['MiscMaz'] = max(Misc_list)

    try:
        LResource['ImportNumberofDLL'] = len(pefile_info.DIRECTORY_ENTRY_EXPORT.symbols)
        LResource['SymbolExportNumber'] = len(pefile_info.DIRECTORY_ENTRY_EXPORT.symbols)
    except:
        LResource['ImportNumberofDLL'] = 0
        LResource['SymbolExportNumber'] = 0

    #add md5 for uniqueness
    try:
        LResource['md5'] = hashlib.md5(open(file_path, "rb").read()).hexdigest()
        LResource['sha1'] = hashlib.sha1(open(file_path, "rb").read()).hexdigest()
        LResource['sha256'] = hashlib.sha256(open(file_path, "rb").read()).hexdigest()
    except:
        LResource['md5'] = 0
        LResource['sha1'] = 0
        LResource['sha256'] = 0

    return LResource

def EXTRACT_FILE_HEADER_INFO(file_path):
    """
    This function extracts file Header Info for the exe file
    
    Input: Exe file path is given as an input
    Ouptut: Dictionary with various values
    """
    pefile_info = pefile.PE(file_path)
    LResource = {}
    LResource['Machine'] = pefile_info.FILE_HEADER.Machine
    LResource['SizeOfOptionalHeader'] = pefile_info.FILE_HEADER.SizeOfOptionalHeader
    LResource['Characteristics'] = pefile_info.FILE_HEADER.Characteristics
    LResource['NumberofSections'] = pefile_info.FILE_HEADER.NumberOfSections

    try:
        LResource['TimeDateStamp'] = pefile_info.FILE_HEADER.TimeDateStamp
        LResource['PointerToSymbolTable'] = pefile_info.FILE_HEADER.PointerToSymbolTable
    except:
        LResource['TimeDateStamp'] = 0
        LResource['PointerToSymbolTable'] = 0

    LResource['NumberOfSymbols'] = pefile_info.FILE_HEADER.NumberOfSymbols
    return LResource

def EXTRACT_DIRECTORY_ENTRY_LOAD_CONFIG(file_path):
    """
    This fucntion extracts directory load config of the exe files
    
    Input: File path is of the exe is given as an input
    Output: Returns the dictionary with values
    """
    pe = pefile.PE(file_path)
    LResource = {}
    try:
        LResource['Load_GlobalFlagsClear'] = pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.GlobalFlagsClear
        LResource['Load_GlobalFlagsSet'] = pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.GlobalFlagsSet
    except:
        LResource['Load_GlobalFlagsClear'] = 0
        LResource['Load_GlobalFlagsSet'] = 0

    try:
        LResource['Load_GlobalFlagsSet'] = pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.GlobalFlagsSet
        LResource['Load_CriticalSelectionDefaultTimeout'] = pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.CriticalSelectionDefaultTimeout
        LResource['Load_DeCommitFreeBlockThreshold'] = pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.DeCommitFreeBlockThreshold
    except:
        LResource['Load_GlobalFlagsSet'] = 0
        LResource['Load_CriticalSelectionDefaultTimeout'] = 0
        LResource['Load_DeCommitFreeBlockThreshold'] = 0

    try:
        LResource['Load_DeCommitTotalFreeThreshold'] = pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.DeCommitTotalFreeThreshold
        LResource['Load_LockPrefixTable'] = pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.LockPrefixTable
        LResource['Load_VitualMemoryThreshold'] = pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.VitualMemoryThreshold
    except:
        LResource['Load_DeCommitTotalFreeThreshold'] = 0
        LResource['Load_LockPrefixTable'] = 0
        LResource['Load_VitualMemoryThreshold'] = 0

    try:
        LResource['Load_ProcessHeapFlags'] = pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.ProcessHeapFlags
        LResource['Load_ProcessAffinityMask'] = pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.ProcessAffinityMask
        LResource['Load_CSDVersion'] = pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.CSDVersion
    except:
        LResource['Load_ProcessHeapFlags'] = 0
        LResource['Load_ProcessAffinityMask'] = 0
        LResource['Load_CSDVersion'] = 0

    try:
        LResource['Load_Reserved1'] = pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.Reserved1
        LResource['Load_EditList'] = pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.EditList
        LResource['Load_SecurityCookie'] = pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.SecurityCookie
    except:
        LResource['Load_Reserved1'] = 0
        LResource['Load_EditList'] = 0
        LResource['Load_SecurityCookie'] = 0

    try:
        LResource['Load_SEHandlerTable'] = pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.SEHandlerTable
        LResource['Load_SEHandlerCount'] = pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.SEHandlerCount
        LResource['Load_GuardCFCheckFunctionPointer'] = pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.GuardCFCheckFunctionPointer
    except:
        LResource['Load_SEHandlerTable'] = 0
        LResource['Load_SEHandlerCount'] = 0
        LResource['Load_GuardCFCheckFunctionPointer'] = 0

    try:
        LResource['Load_Reserved2'] = pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.Reserved2
        LResource['Load_GuardCFFunctionTable'] = pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.GuardCFFunctionTable
        LResource['Load_GuardCFFunctionCount'] = pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.GuardCFFunctionCount
        LResource['Load_GuardFlags'] = pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.GuardFlags
    except:
        LResource['Load_Reserved2'] = 0
        LResource['Load_GuardCFFunctionTable'] = 0
        LResource['Load_GuardCFFunctionCount'] = 0
        LResource['Load_GuardFlags'] = 0

    return LResource

def EXTRACT_DOS_HEADER(file_path):
    """
    This fucntion extracts the DOS Header info from the exe file
    
    Input: File path of the exe is given as input
    Ouput: Dictionary is returned with different fields and values
    """
    LResource = {}
    pe = pefile.PE(file_path)

    try:
        LResource['e_magic'] = pe.DOS_HEADER.e_magic
        LResource['e_cblp'] = pe.DOS_HEADER.e_cblp
        LResource['e_cp'] = pe.DOS_HEADER.e_cp
    except:
        LResource['e_magic'] = 0
        LResource['e_cblp'] = 0
        LResource['e_cp'] = 0

    try:
        LResource['e_crlc'] = pe.DOS_HEADER.e_crlc
        LResource['e_cparhdr'] = pe.DOS_HEADER.e_cparhdr
        LResource['e_minallac'] = pe.DOS_HEADER.e_minallac
    except:
        LResource['e_crlc'] = 0
        LResource['e_cparhdr'] = 0
        LResource['e_minalloc'] = 0

    try:
        LResource['e_maxalloc'] = pe.DOS_HEADER.e_maxalloc
        LResource['e_ss'] = pe.DOS_HEADER.e_ss
        LResource['e_sp'] = pe.DOS_HEADER.e_sp
    except:
        LResource['e_maxalloc'] = 0
        LResource['e_ss'] = 0
        LResource['e_sp'] = 0

    try:
        LResource['e_csum'] = pe.DOS_HEADER.e_csum
        LResource['e_ip'] = pe.DOS_HEADER.e_ip
        LResource['e_cs'] = pe.DOS_HEADER.e_cs
    except:
        LResource['e_csum'] = 0
        LResource['e_ip'] = 0
        LResource['e_cs'] = 0

    try:
        LResource['e_lfarlc'] = pe.DOS_HEADER.e_lfarlc
        LResource['e_ovno'] = pe.DOS_HEADER.e_ovno
        LResource['e_res'] = len(pe.DOS_HEADER.e_res)
    except:
        LResource['e_lfarlc'] = 0
        LResource['e_ovno'] = 0
        LResource['e_res'] = 0

    try:
        LResource['e_oemid'] = pe.DOS_HEADER.e_oemid
        LResource['e_oeminfo'] = pe.DOS_HEADER.e_oeminfo
        LResource['e_res2'] = len(pe.DOS_HEADER.e_res2)
        LResource['e_lfanew'] = pe.DOS_HEADER.e_lfanew
    except:
        LResource['e_oemid'] = 0
        LResource['e_oeminfo'] = 0
        LResource['e_res2'] = 0
        LResource['e_lfanew'] = 0

    return LResource

def EXTRACT_DIRECTORY_ENTRY_RESOURCE(file_path):
    """
    This function returns the Resource values from exe header of the file
    
    Input: File path of the exe
    Output: Dictionary with various fields and values of the header of the exe file
    """
    pefile_info = pefile.PE(file_path)
    LResource = {}

    try:
        LResource['Directory_Characteristics'] = pefile_info.DIRECTROY_ENTRY_RESOURCE.struct.Characteristics
    except:
        LResource['Directory_Characteristics'] = 0

    try:
        LResource['Directory_TimeDateStamp'] = pefile_info.DIRECTROY_ENTRY_RESOURCE.struct.TimeDateStamp
    except:
        LResource['Directory_TimeDateStamp'] = 0

    try:
        LResource['Directory_NumberOfNamedEntries'] = pefile_info.DIRECTROY_ENTRY_RESOURCE.struct.NumberOfNamedEntries
    except:
        LResource['Directory_NumberOfNamedEntries'] = 0

    try:
        LResource['Directory_NumberOfIdEntries'] = pefile_info.DIRECTROY_ENTRY_RESOURCE.struct.NumberOfIdEntries
    except:
        LResource['Directory_NumberOfIdEntries'] = 0

    return LResource

#define all the columns of the dictionary in order to store them in the CSV file
columns_ = ['Name',
 'MajorLinkerVersion',
 'MinorLinkerVersion',
 'SizeOfCode',
 'SizeOfInitializedData',
 'SizeOfUninitializedData',
 'AddressOfEntryPoint',
 'BaseOfCode',
 'ImageBase',
 'SectionAlignment',
 'FileAlignment',
 'MajorOperatingSystemVersion',
 'MajorImageVersion',
 'MinorImageVersion',
 'MajorSubsystemVerison',
 'MinorSubsystemVersion',
 'SizeOfImage',
 'SizeOfHeaders',
 'Subsystem',
 'DllCharacteristics',
 'SizeOfStackReserve',
 'SizeOfStackCommit',
 'SizeOfHeapReserve',
 'SizeOfHeapCommit',
 'LoaderFlags',
 'NumberOfRvaAndSizes',
 'SelectionsMeanEntropy',
 'SectionsMinEntropy',
 'SectionMaxEntropy',
 'CharacteristicsMean',
 'CharacteristicsMin',
 'CharacteristicsMax',
 'MiscMean',
 'MiscMin',
 'MiscMaz',
 'ImportNumberofDLL',
 'SymbolExportNumber',
 'md5',
 'sha1',
 'sha256',
 'Machine',
 'SizeOfOptionalHeader',
 'Characteristics',
 'NumberofSections',
 'TimeDateStamp',
 'PointerToSymbolTable',
 'NumberOfSymbols',
 'Load_GlobalFlagsClear',
 'Load_GlobalFlagsSet',
 'Load_CriticalSelectionDefaultTimeout',
 'Load_DeCommitFreeBlockThreshold',
 'Load_DeCommitTotalFreeThreshold',
 'Load_LockPrefixTable',
 'Load_VitualMemoryThreshold',
 'Load_ProcessHeapFlags',
 'Load_ProcessAffinityMask',
 'Load_CSDVersion',
 'Load_Reserved1',
 'Load_EditList',
 'Load_SecurityCookie',
 'Load_SEHandlerTable',
 'Load_SEHandlerCount',
 'Load_GuardCFCheckFunctionPointer',
 'Load_Reserved2',
 'Load_GuardCFFunctionTable',
 'Load_GuardCFFunctionCount',
 'Load_GuardFlags',
 'e_magic',
 'e_cblp',
 'e_cp',
 'e_crlc',
 'e_cparhdr',
 'e_minalloc',
 'e_maxalloc',
 'e_ss',
 'e_sp',
 'e_csum',
 'e_ip',
 'e_cs',
 'e_lfarlc',
 'e_ovno',
 'e_res',
 'e_oemid',
 'e_oeminfo',
 'e_res2',
 'e_lfanew',
 'Directory_Characteristics',
 'Directory_TimeDateStamp',
 'Directory_NumberOfNamedEntries',
 'Directory_NumberOfIdEntries',
 'Malicious']

def WriteDictToCSV(columns_, dictData, csvFileName, writeHeader=0):
    """
    This fucntion writes the dictionary data to a CSV
    
    Inputs:
        columns_: Give the header info in the form of the list
        dictData: Give the dictionary with similar headers as that of the columns_
        writeHeader: By default this is 0, which means no header is written in the file. To write the header make this 1
        csvFileName: Write the name of the file where the csv values are supposed to be written
    """
    while {} in dictData:
        dictData.remove({})
    try:
        with open(csvFileName, 'a', newline='') as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames = columns_)
            if writeHeader:
                writer.writeheader()
            for data in dictData:
                writer.writerow(data)
    except IOError:
        print("Error")
    return

def fromFilePaths(filePath):
    """
    This fucntion reads the absolute paths from the path file and converts thoses paths to List
    
    Input:
        filePath: path of the file where absolute paths of the exes are present
    Output:
        Retruns the paths in the form of list
    """
    path_exe = []
    with open(filePath) as csvfile:
        reader = csv.reader(csvfile, delimiter='\n')
        for row in reader:
            path_exe.append(row)
    return path_exe

def extract_exe_info(exePath, mal=0):
    """
    This function takes the absolute path of the exe file and extracts all the header information
    
    Input:
        exePath: Absolute path for the exe file
        mal: Default value is 0 i.e. non-malicious 
            Tag the file whether it is malicious or non malicious, for testing just ignore this parameter 
    Output:
        Return the dictionary with 91 fields and values along with it
    """
    Resource = {}
    file_path = exePath
    try:
        Resource = EXTRACT_OPTIONAL_HEADER_INFO(file_path)
        Resource.update(EXTRACT_FILE_HEADER_INFO(file_path))
        Resource.update(EXTRACT_DIRECTORY_ENTRY_LOAD_CONFIG(file_path))
        Resource.update(EXTRACT_DOS_HEADER(file_path))
        Resource.update(EXTRACT_DIRECTORY_ENTRY_RESOURCE(file_path))
        Resource['Malicious'] = mal
    except:
        print("Header info could not be extracted from this file path %s" % (exePath))
    
    return Resource

def folderScrapeExe(topdir, exten, logname):
    """
    This function scrapes for what extension the user wants and writes the paths
    in the logfile
    
    Inputs:
        topdir: The top argument for walk
        exten: The extension to search for
        logname: where will be it logged
    Outputs:
        No outputs, instead the paths are written on the log files
    """
    results = str()
    for dirpath, dirnames, files in os.walk(topdir):
        for name in files:
            if name.lower().endswith(exten):
                # Save to results string instead of print ing
                results += '%s\n' % os.path.join(dirpath, name)
     
    # Write results to logfile
    with open(logname, 'a') as logfile:
        logfile.write(results)

def seperate_path_filename(paths_files, paths, files):
    """
    This fucntion seperates the filename from the absolute path for every file in paths_files list
    
    Inputs:
        paths_files: List of all exes absolute paths
    Outputs:
        paths: returns the absolute paths without the filename of the exe in list
        files: resturns the file names without the paths
    """
    for i in paths_files:
        temp = i[0].split('\\')
        paths.append(i[0].replace(temp[-1], ''))
        files.append(temp[-1])

def convertExeToBytes(file, src_path, dst_path):
    """
    This function converts the exe file to bytes file
    
    Inputs:
        file: name of the file which is to be converted to bytes
        src_path: source path of the file without the filename
        dst_path: destination path for the bytes files
    Output:
        The files converted to bytes are written in the destination directory
    """
    filename = src_path + file
    try:
        with open(filename, 'rb') as f:
            content = f.read()
        
        space = 1
        
        with open(dst_path + file, 'w') as g:
            for i in content:
                f = hex(i)[2:]
                if len(f) == 1:
                    f = '0' + f
                with redirect_stdout(g):
                    print('%2s' % f, end = " ")
                if space % 16 == 0:
                    with redirect_stdout(g):
                        print("\n", end = "")
                
                space = space + 1
    except:
        print('A file couldnot be opened')
        
def convert_bytes_image(filename, src_path, dst_path, width):
    """
    This function converts bytes file to the image file in the specified path
    with the specified image width size
    
    Inputs:
        filename: Name of the bytes files to convert to image
        src_path: source path file of the byte file
        dst_path: destination path where the image is saved
        width: Specify the width of the image, the height is adjusted accordingly
        
    Ouptut:
        The images are converted and stored in the destination path
    """
    loc = src_path + filename
    hexar = []
    try:
        with open(loc, 'rb') as f: 
            for line in f:
                hexar.extend(int(el, 16) for el in line.split() if el != b'??')
        rn = len(hexar) // width
        fh = np.reshape(hexar[:rn * width], (-1, width))
        fh = np.uint8(fh)
        img = Image.fromarray(fh)
        img.save(dst_path + filename + '.tiff' ,"TIFF")
    except:
        print('Could Not be converted')

